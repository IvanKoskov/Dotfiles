{
  "version": 3,
  "sources": ["../src/delete-unsupported-runtimes.command.tsx", "../src/shared/operation-with-user-feedback.ts", "../src/shared/exec-async.ts", "../src/shared/group-by.ts", "../src/services/xcode-runtime.service.ts"],
  "sourcesContent": ["import { operationWithUserFeedback } from \"./shared/operation-with-user-feedback\";\nimport { Alert, confirmAlert, Icon } from \"@raycast/api\";\nimport { XcodeRuntimeService } from \"./services/xcode-runtime.service\";\n\nexport default async () => {\n  const alertOptions: Alert.Options = {\n    icon: Icon.Trash,\n    title: \"Delete unsupported runtimes\",\n    message: \"Are you sure you want to delete all unsupported runtimes?\",\n    primaryAction: {\n      title: \"Delete\",\n      style: Alert.ActionStyle.Destructive,\n    },\n  };\n  if (!(await confirmAlert(alertOptions))) {\n    return;\n  }\n  await operationWithUserFeedback(\n    \"Deleting unsupported runtimes\",\n    \"Successfully deleted unsupported runtimes\",\n    \"An error occurred while trying to delete unsupported runtimes\",\n    XcodeRuntimeService.deleteUnsupportedXcodeRuntimes\n  );\n};\n", "import { showToast, Toast } from \"@raycast/api\";\n\n/**\n * OperationWithUserFeedback Result\n */\nexport interface OperationWithUserFeedbackResult<T> {\n  /**\n   * Bool value if operation succeeded or failed\n   */\n  isSuccess: boolean;\n  /**\n   * The optional generic Result\n   */\n  result?: T;\n  /**\n   * The Toast\n   */\n  toast: Toast;\n}\n\n/**\n * Perform an operation with user feedback while loading, on success and on failure\n * @param loadingTitle The loading title while the operation is running\n * @param successTitle The success title when the operation succeeded\n * @param failureTitle The failure title when the operation failed\n * @param operation The operation to perform\n */\nexport async function operationWithUserFeedback<T>(\n  loadingTitle: string,\n  successTitle: string,\n  failureTitle: string,\n  operation: () => Promise<T>\n): Promise<OperationWithUserFeedbackResult<T>> {\n  // Show Toast\n  const toast = await showToast({\n    style: Toast.Style.Animated,\n    title: loadingTitle,\n  });\n  try {\n    // Perform operation\n    const result = await operation();\n    // Show success Toast\n    toast.style = Toast.Style.Success;\n    toast.title = successTitle;\n    return {\n      isSuccess: true,\n      result: result,\n      toast: toast,\n    };\n  } catch (error) {\n    // Log error\n    console.error(error);\n    // Show failure Toast\n    toast.style = Toast.Style.Failure;\n    toast.title = failureTitle;\n    toast.message = `${error}`;\n    return {\n      isSuccess: false,\n      toast: toast,\n    };\n  }\n}\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n/**\n * Spawns a shell then executes the command within that shell, buffering any generated output.\n */\nexport const execAsync = promisify(exec);\n", "/**\n * Group a given array by a given key into a Map\n * Source: https://stackoverflow.com/a/38327540\n * @param list The list\n * @param keyProvider The key provider that is used for grouping\n */\nexport function groupBy<Key, Value>(\n  list: Value[],\n  keyProvider: (input: Value) => Key\n): { key: Key; values: Value[] }[] {\n  // Initialize the grouping Map\n  const map = new Map<Key, Value[]>();\n  // For each value in the list\n  for (const value of list) {\n    // Retrieve the key from the key provider\n    const key = keyProvider(value);\n    // Retrieve the current values from the grouping Map\n    const values = map.get(key);\n    // Check if values is falsy\n    if (!values) {\n      // Set value as array to grouping Map\n      map.set(key, [value]);\n    } else {\n      // Push value to collection\n      values.push(value);\n    }\n  }\n  // Return groups\n  return Array.from(map.keys()).map((key) => {\n    return { key: key, values: map.get(key) ?? [] };\n  });\n}\n", "import { XcodeRuntimeGroup } from \"../models/xcode-runtime/xcode-runtime-group.model\";\nimport { XcodeRuntimePlatformFilter } from \"../models/xcode-runtime/xcode-runtime-platform-filter.model\";\nimport { XcodeRuntimePlatform } from \"../models/xcode-runtime/xcode-runtime-platform.model\";\nimport { XcodeRuntime } from \"../models/xcode-runtime/xcode-runtime.model\";\nimport { execAsync } from \"../shared/exec-async\";\nimport { groupBy } from \"../shared/group-by\";\n\n/**\n * XcodeRuntimeService\n */\nexport class XcodeRuntimeService {\n  static async xcodeRuntimeGroups(filter: XcodeRuntimePlatformFilter): Promise<XcodeRuntimeGroup[]> {\n    const runtimes = await XcodeRuntimeService.xcodeRuntimes();\n    return groupBy(\n      runtimes.filter(\n        (value) =>\n          filter === XcodeRuntimePlatformFilter.all || value.platform === (filter as unknown as XcodeRuntimePlatform)\n      ),\n      (runtime) => runtime.platform\n    )\n      .map((group) => {\n        return {\n          platform: group.key,\n          runtimes: group.values,\n        };\n      })\n      .sort((lhs, rhs) => lhs.platform.localeCompare(rhs.platform));\n  }\n\n  /**\n   * Retrieve all installed XcodeRuntimes\n   */\n  static async xcodeRuntimes(): Promise<XcodeRuntime[]> {\n    const output = await execAsync(\"xcrun simctl list -j -v runtimes\");\n    const runtimesResponseJSON = JSON.parse(output.stdout);\n    if (!runtimesResponseJSON || !runtimesResponseJSON.runtimes) {\n      throw [];\n    }\n\n    const result: XcodeRuntime[] = runtimesResponseJSON.runtimes.map(\n      (runtime: {\n        name: string;\n        isAvailable: boolean;\n        platform: string;\n        version: string;\n        buildversion: string;\n        lastUsage: Record<string, string>;\n      }): XcodeRuntime => {\n        const lastUsageValues = Object.values(runtime.lastUsage || {});\n        const lastUsageDate =\n          lastUsageValues.length > 0\n            ? new Date(Math.max(...lastUsageValues.map((timestamp) => new Date(timestamp).getTime())))\n            : undefined;\n\n        const isDefaultDate = lastUsageDate && lastUsageDate.getFullYear() === 1;\n        const lastUsage = isDefaultDate ? undefined : lastUsageDate;\n        return {\n          name: runtime.name,\n          isSupported: runtime.isAvailable,\n          platform: runtime.platform as unknown as XcodeRuntimePlatform,\n          version: runtime.version,\n          buildVersion: runtime.buildversion,\n          lastUsageDate: lastUsage,\n        };\n      }\n    );\n    return result.sort((lhs, rhs) => rhs.buildVersion.localeCompare(lhs.buildVersion));\n  }\n\n  static async deleteXcodeRuntime(runtime: XcodeRuntime): Promise<void> {\n    await execAsync(`xcrun simctl runtime delete ${runtime.buildVersion}`);\n  }\n\n  static async deleteUnsupportedXcodeRuntimes(): Promise<void> {\n    const runtimes = await XcodeRuntimeService.xcodeRuntimes();\n    const unsupportedRuntimes = runtimes.filter((runtime) => runtime.isSupported === false);\n    for (const runtime of unsupportedRuntimes) {\n      await XcodeRuntimeService.deleteXcodeRuntime(runtime);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["delete_unsupported_runtimes_command_exports", "__export", "delete_unsupported_runtimes_command_default", "__toCommonJS", "import_api", "operationWithUserFeedback", "loadingTitle", "successTitle", "failureTitle", "operation", "toast", "result", "error", "import_api", "import_child_process", "import_util", "execAsync", "groupBy", "list", "keyProvider", "map", "value", "key", "values", "XcodeRuntimeService", "_XcodeRuntimeService", "filter", "runtimes", "groupBy", "value", "runtime", "group", "lhs", "rhs", "output", "execAsync", "runtimesResponseJSON", "lastUsageValues", "lastUsageDate", "timestamp", "lastUsage", "unsupportedRuntimes", "delete_unsupported_runtimes_command_default", "alertOptions", "operationWithUserFeedback", "XcodeRuntimeService"]
}
