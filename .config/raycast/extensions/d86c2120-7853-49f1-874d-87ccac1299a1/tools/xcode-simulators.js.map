{
  "version": 3,
  "sources": ["../../src/tools/xcode-simulators.ts", "../../src/shared/exec-async.ts", "../../src/shared/group-by.ts", "../../src/services/xcode.service.ts", "../../src/models/xcode-simulator/xcode-simulator-open-url-error.model.ts", "../../src/services/xcode-simulator.service.ts"],
  "sourcesContent": ["import { XcodeSimulatorService } from \"../services/xcode-simulator.service\";\n\n/**\n * Returns the Xcode simulators.\n */\nexport default () => XcodeSimulatorService.xcodeSimulators();\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n/**\n * Spawns a shell then executes the command within that shell, buffering any generated output.\n */\nexport const execAsync = promisify(exec);\n", "/**\n * Group a given array by a given key into a Map\n * Source: https://stackoverflow.com/a/38327540\n * @param list The list\n * @param keyProvider The key provider that is used for grouping\n */\nexport function groupBy<Key, Value>(\n  list: Value[],\n  keyProvider: (input: Value) => Key\n): { key: Key; values: Value[] }[] {\n  // Initialize the grouping Map\n  const map = new Map<Key, Value[]>();\n  // For each value in the list\n  for (const value of list) {\n    // Retrieve the key from the key provider\n    const key = keyProvider(value);\n    // Retrieve the current values from the grouping Map\n    const values = map.get(key);\n    // Check if values is falsy\n    if (!values) {\n      // Set value as array to grouping Map\n      map.set(key, [value]);\n    } else {\n      // Push value to collection\n      values.push(value);\n    }\n  }\n  // Return groups\n  return Array.from(map.keys()).map((key) => {\n    return { key: key, values: map.get(key) ?? [] };\n  });\n}\n", "import { execAsync } from \"../shared/exec-async\";\nimport { getApplications } from \"@raycast/api\";\n\n/**\n * XcodeService\n */\nexport class XcodeService {\n  /**\n   * Xcode application bundle identifier\n   */\n  static get bundleIdentifier(): string {\n    return \"com.apple.dt.Xcode\";\n  }\n\n  /**\n   * Xcode download url (Mac App Store)\n   */\n  static get downloadUrl(): string {\n    return \"https://apps.apple.com/app/id497799835\";\n  }\n\n  /**\n   * Xcode Developer Documentation URL Scheme\n   */\n  static get developerDocumentationURLScheme(): string {\n    return \"x-xcode-documentation://\";\n  }\n\n  /**\n   * Retrieve boolean if Xcode is installed\n   */\n  static async isXcodeInstalled(): Promise<boolean> {\n    const applications = await getApplications();\n    return !!applications.find((application) => application.bundleId === XcodeService.bundleIdentifier);\n  }\n\n  /**\n   * Retrieve boolean if Xcode is currently running\n   */\n  static async isXcodeRunning(): Promise<boolean> {\n    try {\n      // prep Xcode process status\n      const output = await execAsync(\"pgrep Xcode\");\n      // Xcode is running if standard output is not empty\n      return output.stdout.trim().length !== 0;\n    } catch {\n      // On error Xcode is not running\n      return false;\n    }\n  }\n\n  /**\n   * Launch Xcode\n   */\n  static launchXcode(): Promise<void> {\n    return execAsync(\n      [\n        // Open Xcode in background (-j)\n        // via bundle identifier (-b)\n        `open -j -b ${XcodeService.bundleIdentifier}`,\n        // Sleep for two seconds to ensure\n        // the process is truly running\n        \"sleep 2\",\n      ].join(\" && \")\n    ).then();\n  }\n}\n", "/**\n * A Xcode Simulator Open Url Error\n */\nexport class XcodeSimulatorOpenUrlError extends Error {\n  /**\n   * Creates a new instance of `XcodeSimulatorOpenUrlError`\n   * @param reason The reason why the url could not be opened\n   */\n  constructor(public reason: XcodeSimulatorOpenUrlErrorReason) {\n    super(reason);\n  }\n}\n\n/**\n * A Xcode Simulator Open Url Error Reason\n */\nexport enum XcodeSimulatorOpenUrlErrorReason {\n  badUrl = \"Bad Url\",\n  xcodeInstallationMissing = \"Xcode is not installed\",\n  bootedSimulatorMissing = \"No simulator booted\",\n}\n", "import { XcodeSimulator } from \"../models/xcode-simulator/xcode-simulator.model\";\nimport { execAsync } from \"../shared/exec-async\";\nimport { XcodeSimulatorGroup } from \"../models/xcode-simulator/xcode-simulator-group.model\";\nimport { XcodeSimulatorState } from \"../models/xcode-simulator/xcode-simulator-state.model\";\nimport { XcodeSimulatorAppAction } from \"../models/xcode-simulator/xcode-simulator-app-action.model\";\nimport { XcodeSimulatorAppPrivacyAction } from \"../models/xcode-simulator/xcode-simulator-app-privacy-action.model\";\nimport { XcodeSimulatorAppPrivacyServiceType } from \"../models/xcode-simulator/xcode-simulator-app-privacy-service-type.model\";\nimport { groupBy } from \"../shared/group-by\";\nimport { XcodeService } from \"./xcode.service\";\nimport {\n  XcodeSimulatorOpenUrlError,\n  XcodeSimulatorOpenUrlErrorReason,\n} from \"../models/xcode-simulator/xcode-simulator-open-url-error.model\";\nimport { XcodeSimulatorStateFilter } from \"../models/xcode-simulator/xcode-simulator-state-filter.model\";\n\n/**\n * XcodeSimulatorService\n */\nexport class XcodeSimulatorService {\n  /**\n   * Launches simulator application\n   */\n  static launchSimulatorApplication(): Promise<void> {\n    return execAsync(`open -b \"com.apple.iphonesimulator\"`).then();\n  }\n\n  /**\n   * Retrieve all XcodeSimulatorGroups\n   *\n   * @param filter The XcodeSimulatorStateFilter to filter the XcodeSimulatorGroups\n   */\n  static async xcodeSimulatorGroups(filter: XcodeSimulatorStateFilter): Promise<XcodeSimulatorGroup[]> {\n    const simulators = await XcodeSimulatorService.xcodeSimulators();\n    return groupBy(\n      simulators.filter(\n        (value) =>\n          filter === XcodeSimulatorStateFilter.all || value.state === (filter as unknown as XcodeSimulatorState)\n      ),\n      (simulator) => simulator.runtime\n    )\n      .map((group) => {\n        return { runtime: group.key, simulators: group.values };\n      })\n      .sort((lhs, rhs) => lhs.runtime.localeCompare(rhs.runtime));\n  }\n\n  /**\n   * Retrieve all installed XcodeSimulators\n   */\n  static async xcodeSimulators(): Promise<XcodeSimulator[]> {\n    // Execute command\n    const output = await execAsync(\"xcrun simctl list -j -v devices\");\n    // Parse stdout as JSON\n    const devicesResponseJSON = JSON.parse(output.stdout);\n    // Check if JSON or devices within the JSON are not available\n    if (!devicesResponseJSON || !devicesResponseJSON.devices) {\n      // Return empty simulators array\n      throw [];\n    }\n    // Initialize XcodeSimulators\n    const simulators: XcodeSimulator[] = [];\n    // For each DeviceGroup\n    for (const deviceGroup in devicesResponseJSON.devices) {\n      // Initialize runtime components from DeviceGroup\n      const runtimeComponents = deviceGroup.substring(deviceGroup.lastIndexOf(\".\") + 1).split(\"-\");\n      // Initialize runtime string\n      const runtime = [runtimeComponents.shift(), runtimeComponents.join(\".\")].join(\" \");\n      // Push Simulators in DeviceGroup\n      simulators.push(\n        ...devicesResponseJSON.devices[deviceGroup].map((simulator: XcodeSimulator) => {\n          simulator.runtime = runtime;\n          return simulator;\n        })\n      );\n    }\n    // Return XcodeSimulators\n    return simulators;\n  }\n\n  /**\n   * Boot XcodeSimulator\n   * @param xcodeSimulatorUDID The XcodeSimulator UDID to boot\n   */\n  static boot(xcodeSimulatorUDID: string): Promise<void> {\n    return execAsync(`xcrun simctl boot ${xcodeSimulatorUDID}`).then(() => {\n      // Silently launch Simulator application\n      XcodeSimulatorService.launchSimulatorApplication();\n    });\n  }\n\n  /**\n   * Shutdown XcodeSimulator\n   * @param xcodeSimulatorUDID The XcodeSimulator UDID to shutdown\n   */\n  static shutdown(xcodeSimulatorUDID: string): Promise<void> {\n    // Shutdown Simulator\n    return execAsync(`xcrun simctl shutdown ${xcodeSimulatorUDID}`).then();\n  }\n\n  /**\n   * Toggle XcodeSimulator\n   */\n  static toggle(xcodeSimulator: XcodeSimulator): Promise<void> {\n    switch (xcodeSimulator.state) {\n      case XcodeSimulatorState.booted:\n        return XcodeSimulatorService.shutdown(xcodeSimulator.udid);\n      case XcodeSimulatorState.shuttingDown:\n        return Promise.resolve();\n      case XcodeSimulatorState.shutdown:\n        return XcodeSimulatorService.boot(xcodeSimulator.udid);\n    }\n  }\n\n  /**\n   * Restart XcodeSimulator\n   * @param xcodeSimulatorUDID The XcodeSimulator udid to restart\n   */\n  static async restart(xcodeSimulatorUDID: string): Promise<void> {\n    await XcodeSimulatorService.shutdown(xcodeSimulatorUDID);\n    await XcodeSimulatorService.boot(xcodeSimulatorUDID);\n  }\n\n  /**\n   * Perform a XcodeSimulator AppAction\n   * @param action The XcodeSimulatorAppAction\n   * @param bundleIdentifier The bundle identifier of the application\n   * @param xcodeSimulator The XcodeSimulator\n   */\n  static async app(\n    action: XcodeSimulatorAppAction,\n    bundleIdentifier: string,\n    xcodeSimulator: XcodeSimulator\n  ): Promise<void> {\n    try {\n      // Boot Xcode Simulator and ignore any errors\n      await XcodeSimulatorService.boot(xcodeSimulator.udid);\n      // eslint-disable-next-line no-empty\n    } catch {}\n    // Launch application by bundle identifier\n    return execAsync([\"xcrun\", \"simctl\", action, xcodeSimulator.udid, bundleIdentifier].join(\" \")).then();\n  }\n\n  /**\n   * Perform a XcodeSimulator AppPrivacyAction for a given AppPrivacyServiceType\n   * @param action The XcodeSimulatorAppPrivacyAction\n   * @param serviceType The XcodeSimulatorAppPrivacyServiceType\n   * @param bundleIdentifier The bundle identifier of the application\n   * @param xcodeSimulator The XcodeSimulator\n   */\n  static async appPrivacy(\n    action: XcodeSimulatorAppPrivacyAction,\n    serviceType: XcodeSimulatorAppPrivacyServiceType,\n    bundleIdentifier: string,\n    xcodeSimulator: XcodeSimulator\n  ): Promise<void> {\n    try {\n      // Boot Xcode Simulator and ignore any errors\n      await XcodeSimulatorService.boot(xcodeSimulator.udid);\n      // eslint-disable-next-line no-empty\n    } catch {}\n    return execAsync(\n      [\"xcrun\", \"simctl\", \"privacy\", xcodeSimulator.udid, action, serviceType, bundleIdentifier].join(\" \")\n    ).then();\n  }\n\n  /**\n   * Bool value if a given url is valid to be opened in a simulator\n   * @param url The url to validate.\n   */\n  static isValidUrl(url: string): boolean {\n    return /\\w+:\\/\\/+/.test(url);\n  }\n\n  /**\n   * Opens a URL in a Simulator\n   * @param url The url which should be opened\n   * @param simulatorUDID The optional simulator udid where the url should be opened.\n   */\n  static async openUrl(url: string, simulatorUDID?: string) {\n    // Trim url\n    const trimmedUrl = url.trim();\n    // Check if the url has a valid scheme e.g. (maps://, https://raycast.com)\n    if (!XcodeSimulatorService.isValidUrl(trimmedUrl)) {\n      throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.badUrl);\n    }\n    // Check if no simulator udid is presented\n    if (!simulatorUDID) {\n      // Check if Xcode is not installed\n      if (!(await XcodeService.isXcodeInstalled())) {\n        // Throw error\n        throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.xcodeInstallationMissing);\n      }\n      // Retrieve all simulators\n      const simulators = await XcodeSimulatorService.xcodeSimulators();\n      // Check if at least one simulator is booted\n      if (!simulators.some((xcodeSimulator) => xcodeSimulator.state === XcodeSimulatorState.booted)) {\n        // Otherwise throw an error\n        throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.bootedSimulatorMissing);\n      }\n    }\n    // Open URL in simulator\n    return execAsync([\"xcrun\", \"simctl\", \"openurl\", simulatorUDID ?? \"booted\", `\"${trimmedUrl}\"`].join(\" \")).then(\n      () => {\n        // Silently launch Simulator application\n        XcodeSimulatorService.launchSimulatorApplication();\n      }\n    );\n  }\n\n  /**\n   * Sends a push notification to a Xcode Simulator\n   * @param xcodeSimulator The Xcode Simulator\n   * @param bundleIdentifier The bundle identifier of the app\n   * @param payloadPath The path of the push notification payload\n   */\n  static async sendPushNotification(\n    xcodeSimulator: XcodeSimulator,\n    bundleIdentifier: string,\n    payloadPath: string\n  ): Promise<void> {\n    return execAsync(`xcrun simctl push ${xcodeSimulator.udid} ${bundleIdentifier} ${payloadPath}`).then();\n  }\n\n  /**\n   * Deletes App Files without uninstalling the app\n   * @param containerPath App Container Directory\n   * @param appGroupPath App Group Directory\n   */\n  static async deleteAppFiles(containerPath: string, appGroupPath?: string): Promise<void> {\n    const deleteAppGroupPathPromise = appGroupPath ? execAsync(`rm -rf ${appGroupPath}`) : Promise.resolve();\n    return Promise.all([execAsync(`rm -rf ${containerPath}`), deleteAppGroupPathPromise]).then();\n  }\n\n  /**\n   * Rename XcodeSimulator\n   * @param xcodeSimulator The Xcode Simulator to rename\n   * @param name The new simulator name\n   */\n  static async rename(xcodeSimulator: XcodeSimulator, name: string): Promise<void> {\n    return execAsync(`xcrun simctl rename ${xcodeSimulator.udid} '${name}' `).then();\n  }\n\n  /**\n   * Deletes a XcodeSimulator\n   * @param xcodeSimulator The Xcode Simulator to delete\n   */\n  static async delete(xcodeSimulator: XcodeSimulator): Promise<void> {\n    return execAsync(`xcrun simctl delete ${xcodeSimulator.udid}`).then();\n  }\n\n  /**\n   * Trigger iCloud Sync for XcodeSimulator\n   * @param xcodeSimulator The Xcode Simulator to trigger iCloud Sync to\n   */\n  static async triggerIcloudSync(xcodeSimulator: XcodeSimulator): Promise<void> {\n    return execAsync(`xcrun simctl icloud_sync ${xcodeSimulator.udid}`).then();\n  }\n}\n"],
  "mappings": "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",
  "names": ["xcode_simulators_exports", "__export", "xcode_simulators_default", "__toCommonJS", "import_child_process", "import_util", "execAsync", "groupBy", "list", "keyProvider", "map", "value", "key", "values", "import_api", "XcodeService", "_XcodeService", "application", "execAsync", "XcodeSimulatorOpenUrlError", "reason", "XcodeSimulatorService", "_XcodeSimulatorService", "execAsync", "filter", "simulators", "groupBy", "value", "simulator", "group", "lhs", "rhs", "output", "devicesResponseJSON", "deviceGroup", "runtimeComponents", "runtime", "xcodeSimulatorUDID", "xcodeSimulator", "action", "bundleIdentifier", "serviceType", "url", "simulatorUDID", "trimmedUrl", "XcodeSimulatorOpenUrlError", "XcodeService", "payloadPath", "containerPath", "appGroupPath", "deleteAppGroupPathPromise", "name", "xcode_simulators_default", "XcodeSimulatorService"]
}
