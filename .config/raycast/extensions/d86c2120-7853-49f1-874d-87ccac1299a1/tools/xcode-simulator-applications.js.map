{
  "version": 3,
  "sources": ["../../src/tools/xcode-simulator-applications.ts", "../../src/shared/exec-async.ts", "../../src/shared/group-by.ts", "../../src/services/xcode.service.ts", "../../src/models/xcode-simulator/xcode-simulator-open-url-error.model.ts", "../../src/services/xcode-simulator.service.ts", "../../src/shared/fs-async.ts", "../../src/services/xcode-simulator-application.service.ts"],
  "sourcesContent": ["import { XcodeSimulatorApplicationService } from \"../services/xcode-simulator-application.service\";\n\n/**\n * Returns the Xcode Simulator applications / builds.\n */\nexport default () => XcodeSimulatorApplicationService.xcodeSimulatorApplications();\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n/**\n * Spawns a shell then executes the command within that shell, buffering any generated output.\n */\nexport const execAsync = promisify(exec);\n", "/**\n * Group a given array by a given key into a Map\n * Source: https://stackoverflow.com/a/38327540\n * @param list The list\n * @param keyProvider The key provider that is used for grouping\n */\nexport function groupBy<Key, Value>(\n  list: Value[],\n  keyProvider: (input: Value) => Key\n): { key: Key; values: Value[] }[] {\n  // Initialize the grouping Map\n  const map = new Map<Key, Value[]>();\n  // For each value in the list\n  for (const value of list) {\n    // Retrieve the key from the key provider\n    const key = keyProvider(value);\n    // Retrieve the current values from the grouping Map\n    const values = map.get(key);\n    // Check if values is falsy\n    if (!values) {\n      // Set value as array to grouping Map\n      map.set(key, [value]);\n    } else {\n      // Push value to collection\n      values.push(value);\n    }\n  }\n  // Return groups\n  return Array.from(map.keys()).map((key) => {\n    return { key: key, values: map.get(key) ?? [] };\n  });\n}\n", "import { execAsync } from \"../shared/exec-async\";\nimport { getApplications } from \"@raycast/api\";\n\n/**\n * XcodeService\n */\nexport class XcodeService {\n  /**\n   * Xcode application bundle identifier\n   */\n  static get bundleIdentifier(): string {\n    return \"com.apple.dt.Xcode\";\n  }\n\n  /**\n   * Xcode download url (Mac App Store)\n   */\n  static get downloadUrl(): string {\n    return \"https://apps.apple.com/app/id497799835\";\n  }\n\n  /**\n   * Xcode Developer Documentation URL Scheme\n   */\n  static get developerDocumentationURLScheme(): string {\n    return \"x-xcode-documentation://\";\n  }\n\n  /**\n   * Retrieve boolean if Xcode is installed\n   */\n  static async isXcodeInstalled(): Promise<boolean> {\n    const applications = await getApplications();\n    return !!applications.find((application) => application.bundleId === XcodeService.bundleIdentifier);\n  }\n\n  /**\n   * Retrieve boolean if Xcode is currently running\n   */\n  static async isXcodeRunning(): Promise<boolean> {\n    try {\n      // prep Xcode process status\n      const output = await execAsync(\"pgrep Xcode\");\n      // Xcode is running if standard output is not empty\n      return output.stdout.trim().length !== 0;\n    } catch {\n      // On error Xcode is not running\n      return false;\n    }\n  }\n\n  /**\n   * Launch Xcode\n   */\n  static launchXcode(): Promise<void> {\n    return execAsync(\n      [\n        // Open Xcode in background (-j)\n        // via bundle identifier (-b)\n        `open -j -b ${XcodeService.bundleIdentifier}`,\n        // Sleep for two seconds to ensure\n        // the process is truly running\n        \"sleep 2\",\n      ].join(\" && \")\n    ).then();\n  }\n}\n", "/**\n * A Xcode Simulator Open Url Error\n */\nexport class XcodeSimulatorOpenUrlError extends Error {\n  /**\n   * Creates a new instance of `XcodeSimulatorOpenUrlError`\n   * @param reason The reason why the url could not be opened\n   */\n  constructor(public reason: XcodeSimulatorOpenUrlErrorReason) {\n    super(reason);\n  }\n}\n\n/**\n * A Xcode Simulator Open Url Error Reason\n */\nexport enum XcodeSimulatorOpenUrlErrorReason {\n  badUrl = \"Bad Url\",\n  xcodeInstallationMissing = \"Xcode is not installed\",\n  bootedSimulatorMissing = \"No simulator booted\",\n}\n", "import { XcodeSimulator } from \"../models/xcode-simulator/xcode-simulator.model\";\nimport { execAsync } from \"../shared/exec-async\";\nimport { XcodeSimulatorGroup } from \"../models/xcode-simulator/xcode-simulator-group.model\";\nimport { XcodeSimulatorState } from \"../models/xcode-simulator/xcode-simulator-state.model\";\nimport { XcodeSimulatorAppAction } from \"../models/xcode-simulator/xcode-simulator-app-action.model\";\nimport { XcodeSimulatorAppPrivacyAction } from \"../models/xcode-simulator/xcode-simulator-app-privacy-action.model\";\nimport { XcodeSimulatorAppPrivacyServiceType } from \"../models/xcode-simulator/xcode-simulator-app-privacy-service-type.model\";\nimport { groupBy } from \"../shared/group-by\";\nimport { XcodeService } from \"./xcode.service\";\nimport {\n  XcodeSimulatorOpenUrlError,\n  XcodeSimulatorOpenUrlErrorReason,\n} from \"../models/xcode-simulator/xcode-simulator-open-url-error.model\";\nimport { XcodeSimulatorStateFilter } from \"../models/xcode-simulator/xcode-simulator-state-filter.model\";\n\n/**\n * XcodeSimulatorService\n */\nexport class XcodeSimulatorService {\n  /**\n   * Launches simulator application\n   */\n  static launchSimulatorApplication(): Promise<void> {\n    return execAsync(`open -b \"com.apple.iphonesimulator\"`).then();\n  }\n\n  /**\n   * Retrieve all XcodeSimulatorGroups\n   *\n   * @param filter The XcodeSimulatorStateFilter to filter the XcodeSimulatorGroups\n   */\n  static async xcodeSimulatorGroups(filter: XcodeSimulatorStateFilter): Promise<XcodeSimulatorGroup[]> {\n    const simulators = await XcodeSimulatorService.xcodeSimulators();\n    return groupBy(\n      simulators.filter(\n        (value) =>\n          filter === XcodeSimulatorStateFilter.all || value.state === (filter as unknown as XcodeSimulatorState)\n      ),\n      (simulator) => simulator.runtime\n    )\n      .map((group) => {\n        return { runtime: group.key, simulators: group.values };\n      })\n      .sort((lhs, rhs) => lhs.runtime.localeCompare(rhs.runtime));\n  }\n\n  /**\n   * Retrieve all installed XcodeSimulators\n   */\n  static async xcodeSimulators(): Promise<XcodeSimulator[]> {\n    // Execute command\n    const output = await execAsync(\"xcrun simctl list -j -v devices\");\n    // Parse stdout as JSON\n    const devicesResponseJSON = JSON.parse(output.stdout);\n    // Check if JSON or devices within the JSON are not available\n    if (!devicesResponseJSON || !devicesResponseJSON.devices) {\n      // Return empty simulators array\n      throw [];\n    }\n    // Initialize XcodeSimulators\n    const simulators: XcodeSimulator[] = [];\n    // For each DeviceGroup\n    for (const deviceGroup in devicesResponseJSON.devices) {\n      // Initialize runtime components from DeviceGroup\n      const runtimeComponents = deviceGroup.substring(deviceGroup.lastIndexOf(\".\") + 1).split(\"-\");\n      // Initialize runtime string\n      const runtime = [runtimeComponents.shift(), runtimeComponents.join(\".\")].join(\" \");\n      // Push Simulators in DeviceGroup\n      simulators.push(\n        ...devicesResponseJSON.devices[deviceGroup].map((simulator: XcodeSimulator) => {\n          simulator.runtime = runtime;\n          return simulator;\n        })\n      );\n    }\n    // Return XcodeSimulators\n    return simulators;\n  }\n\n  /**\n   * Boot XcodeSimulator\n   * @param xcodeSimulatorUDID The XcodeSimulator UDID to boot\n   */\n  static boot(xcodeSimulatorUDID: string): Promise<void> {\n    return execAsync(`xcrun simctl boot ${xcodeSimulatorUDID}`).then(() => {\n      // Silently launch Simulator application\n      XcodeSimulatorService.launchSimulatorApplication();\n    });\n  }\n\n  /**\n   * Shutdown XcodeSimulator\n   * @param xcodeSimulatorUDID The XcodeSimulator UDID to shutdown\n   */\n  static shutdown(xcodeSimulatorUDID: string): Promise<void> {\n    // Shutdown Simulator\n    return execAsync(`xcrun simctl shutdown ${xcodeSimulatorUDID}`).then();\n  }\n\n  /**\n   * Toggle XcodeSimulator\n   */\n  static toggle(xcodeSimulator: XcodeSimulator): Promise<void> {\n    switch (xcodeSimulator.state) {\n      case XcodeSimulatorState.booted:\n        return XcodeSimulatorService.shutdown(xcodeSimulator.udid);\n      case XcodeSimulatorState.shuttingDown:\n        return Promise.resolve();\n      case XcodeSimulatorState.shutdown:\n        return XcodeSimulatorService.boot(xcodeSimulator.udid);\n    }\n  }\n\n  /**\n   * Restart XcodeSimulator\n   * @param xcodeSimulatorUDID The XcodeSimulator udid to restart\n   */\n  static async restart(xcodeSimulatorUDID: string): Promise<void> {\n    await XcodeSimulatorService.shutdown(xcodeSimulatorUDID);\n    await XcodeSimulatorService.boot(xcodeSimulatorUDID);\n  }\n\n  /**\n   * Perform a XcodeSimulator AppAction\n   * @param action The XcodeSimulatorAppAction\n   * @param bundleIdentifier The bundle identifier of the application\n   * @param xcodeSimulator The XcodeSimulator\n   */\n  static async app(\n    action: XcodeSimulatorAppAction,\n    bundleIdentifier: string,\n    xcodeSimulator: XcodeSimulator\n  ): Promise<void> {\n    try {\n      // Boot Xcode Simulator and ignore any errors\n      await XcodeSimulatorService.boot(xcodeSimulator.udid);\n      // eslint-disable-next-line no-empty\n    } catch {}\n    // Launch application by bundle identifier\n    return execAsync([\"xcrun\", \"simctl\", action, xcodeSimulator.udid, bundleIdentifier].join(\" \")).then();\n  }\n\n  /**\n   * Perform a XcodeSimulator AppPrivacyAction for a given AppPrivacyServiceType\n   * @param action The XcodeSimulatorAppPrivacyAction\n   * @param serviceType The XcodeSimulatorAppPrivacyServiceType\n   * @param bundleIdentifier The bundle identifier of the application\n   * @param xcodeSimulator The XcodeSimulator\n   */\n  static async appPrivacy(\n    action: XcodeSimulatorAppPrivacyAction,\n    serviceType: XcodeSimulatorAppPrivacyServiceType,\n    bundleIdentifier: string,\n    xcodeSimulator: XcodeSimulator\n  ): Promise<void> {\n    try {\n      // Boot Xcode Simulator and ignore any errors\n      await XcodeSimulatorService.boot(xcodeSimulator.udid);\n      // eslint-disable-next-line no-empty\n    } catch {}\n    return execAsync(\n      [\"xcrun\", \"simctl\", \"privacy\", xcodeSimulator.udid, action, serviceType, bundleIdentifier].join(\" \")\n    ).then();\n  }\n\n  /**\n   * Bool value if a given url is valid to be opened in a simulator\n   * @param url The url to validate.\n   */\n  static isValidUrl(url: string): boolean {\n    return /\\w+:\\/\\/+/.test(url);\n  }\n\n  /**\n   * Opens a URL in a Simulator\n   * @param url The url which should be opened\n   * @param simulatorUDID The optional simulator udid where the url should be opened.\n   */\n  static async openUrl(url: string, simulatorUDID?: string) {\n    // Trim url\n    const trimmedUrl = url.trim();\n    // Check if the url has a valid scheme e.g. (maps://, https://raycast.com)\n    if (!XcodeSimulatorService.isValidUrl(trimmedUrl)) {\n      throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.badUrl);\n    }\n    // Check if no simulator udid is presented\n    if (!simulatorUDID) {\n      // Check if Xcode is not installed\n      if (!(await XcodeService.isXcodeInstalled())) {\n        // Throw error\n        throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.xcodeInstallationMissing);\n      }\n      // Retrieve all simulators\n      const simulators = await XcodeSimulatorService.xcodeSimulators();\n      // Check if at least one simulator is booted\n      if (!simulators.some((xcodeSimulator) => xcodeSimulator.state === XcodeSimulatorState.booted)) {\n        // Otherwise throw an error\n        throw new XcodeSimulatorOpenUrlError(XcodeSimulatorOpenUrlErrorReason.bootedSimulatorMissing);\n      }\n    }\n    // Open URL in simulator\n    return execAsync([\"xcrun\", \"simctl\", \"openurl\", simulatorUDID ?? \"booted\", `\"${trimmedUrl}\"`].join(\" \")).then(\n      () => {\n        // Silently launch Simulator application\n        XcodeSimulatorService.launchSimulatorApplication();\n      }\n    );\n  }\n\n  /**\n   * Sends a push notification to a Xcode Simulator\n   * @param xcodeSimulator The Xcode Simulator\n   * @param bundleIdentifier The bundle identifier of the app\n   * @param payloadPath The path of the push notification payload\n   */\n  static async sendPushNotification(\n    xcodeSimulator: XcodeSimulator,\n    bundleIdentifier: string,\n    payloadPath: string\n  ): Promise<void> {\n    return execAsync(`xcrun simctl push ${xcodeSimulator.udid} ${bundleIdentifier} ${payloadPath}`).then();\n  }\n\n  /**\n   * Deletes App Files without uninstalling the app\n   * @param containerPath App Container Directory\n   * @param appGroupPath App Group Directory\n   */\n  static async deleteAppFiles(containerPath: string, appGroupPath?: string): Promise<void> {\n    const deleteAppGroupPathPromise = appGroupPath ? execAsync(`rm -rf ${appGroupPath}`) : Promise.resolve();\n    return Promise.all([execAsync(`rm -rf ${containerPath}`), deleteAppGroupPathPromise]).then();\n  }\n\n  /**\n   * Rename XcodeSimulator\n   * @param xcodeSimulator The Xcode Simulator to rename\n   * @param name The new simulator name\n   */\n  static async rename(xcodeSimulator: XcodeSimulator, name: string): Promise<void> {\n    return execAsync(`xcrun simctl rename ${xcodeSimulator.udid} '${name}' `).then();\n  }\n\n  /**\n   * Deletes a XcodeSimulator\n   * @param xcodeSimulator The Xcode Simulator to delete\n   */\n  static async delete(xcodeSimulator: XcodeSimulator): Promise<void> {\n    return execAsync(`xcrun simctl delete ${xcodeSimulator.udid}`).then();\n  }\n\n  /**\n   * Trigger iCloud Sync for XcodeSimulator\n   * @param xcodeSimulator The Xcode Simulator to trigger iCloud Sync to\n   */\n  static async triggerIcloudSync(xcodeSimulator: XcodeSimulator): Promise<void> {\n    return execAsync(`xcrun simctl icloud_sync ${xcodeSimulator.udid}`).then();\n  }\n}\n", "import fs from \"fs\";\nimport { PathLike } from \"node:fs\";\n\n/**\n * Exists\n */\nexport const existsAsync = (path: PathLike) => {\n  return fs.promises\n    .access(path, fs.constants.F_OK)\n    .then(() => true)\n    .catch(() => false);\n};\n\n/**\n * Read directory\n */\nexport const readDirectoryAsync = fs.promises.readdir;\n\n/**\n * Make directory\n */\nexport const makeDirectoryAsync = fs.promises.mkdir;\n\n/**\n * Remove directory\n */\nexport const removeDirectoryAsync = fs.promises.rm;\n\n/**\n * Read file\n */\nexport const readFileAsync = fs.promises.readFile;\n\n/**\n * Write file\n */\nexport const writeFileAsync = fs.promises.writeFile;\n\n/**\n * Delete file\n */\nexport const deleteFileAsync = fs.promises.rm;\n", "import { XcodeSimulatorService } from \"./xcode-simulator.service\";\nimport { execAsync } from \"../shared/exec-async\";\nimport { existsAsync, readDirectoryAsync } from \"../shared/fs-async\";\nimport { XcodeSimulator } from \"../models/xcode-simulator/xcode-simulator.model\";\nimport { XcodeSimulatorApplication } from \"../models/xcode-simulator/xcode-simulator-application.model\";\nimport * as Path from \"path\";\nimport { XcodeSimulatorApplicationGroup } from \"../models/xcode-simulator/xcode-simulator-application-group.model\";\nimport { groupBy } from \"../shared/group-by\";\nimport { XcodeSimulatorState } from \"../models/xcode-simulator/xcode-simulator-state.model\";\n\ninterface XcodeSimulatorApplicationPath {\n  /**\n   * The bundle identifier\n   */\n  bundleIdentifier: string;\n  /**\n   * The path (AppGroup | Sandbox)\n   */\n  path: string;\n}\n\n/**\n * XcodeSimulatorApplicationService\n */\nexport class XcodeSimulatorApplicationService {\n  /**\n   * The Simulator SandBox Paths Map Cache\n   */\n  private static simulatorSandBoxPathsCache = new Map<XcodeSimulator, Promise<XcodeSimulatorApplicationPath[]>>();\n\n  /**\n   * The Simulator AppGroup Paths Map Cache\n   */\n  private static simulatorAppGroupPathsCache = new Map<XcodeSimulator, Promise<XcodeSimulatorApplicationPath[]>>();\n\n  /**\n   * Retrieve all XcodeSimulatorApplicationGroups\n   */\n  static async xcodeSimulatorApplicationGroups(): Promise<XcodeSimulatorApplicationGroup[]> {\n    const xcodeSimulatorApplications = await XcodeSimulatorApplicationService.xcodeSimulatorApplications();\n    return groupBy(xcodeSimulatorApplications, (application) => application.simulator).map((group) => {\n      return { simulator: group.key, applications: group.values.sort((lhs, rhs) => lhs.name.localeCompare(rhs.name)) };\n    });\n  }\n\n  /**\n   * Retrieve all XcodeSimulatorApplications\n   */\n  static async xcodeSimulatorApplications(): Promise<XcodeSimulatorApplication[]> {\n    // Retrieve all Simulators\n    const simulators = await XcodeSimulatorService.xcodeSimulators();\n    // Find all Applications installed in each XcodeSimulator\n    return ([] as XcodeSimulatorApplication[]).concat(\n      ...(\n        await Promise.allSettled(simulators.map(XcodeSimulatorApplicationService.findXcodeSimulatorApplications))\n      ).map((result) => (result.status === \"fulfilled\" ? result.value : []))\n    );\n  }\n\n  /**\n   * Find all XcodeSimulatorApplications of a given XcodeSimulator\n   * @param simulator The XcodeSimulator\n   */\n  static async findXcodeSimulatorApplications(simulator: XcodeSimulator): Promise<XcodeSimulatorApplication[]> {\n    // The container application directory path\n    const containerApplicationDirectoryPath = Path.join(simulator.dataPath, \"Containers/Bundle/Application\");\n    // Declare Application Directory Paths\n    let applicationDirectoryPaths: string[];\n    try {\n      // Read application child directories paths\n      applicationDirectoryPaths = await readDirectoryAsync(containerApplicationDirectoryPath, {\n        withFileTypes: true,\n      }).then((entries) => {\n        return entries\n          .filter((entry) => entry.isDirectory())\n          .map((entry) => Path.join(containerApplicationDirectoryPath, entry.name));\n      });\n    } catch {\n      // On error return empty applications\n      return [];\n    }\n    // Retrieve all Applications in parallel\n    const applications = (\n      await Promise.allSettled(\n        applicationDirectoryPaths.map((applicationDirectoryPath) =>\n          XcodeSimulatorApplicationService.findXcodeSimulatorApplication(simulator, applicationDirectoryPath)\n        )\n      )\n    ).map((result) => (result.status === \"fulfilled\" ? result.value : undefined));\n    // Filter out falsy values and return Applications\n    return applications.filter(Boolean) as XcodeSimulatorApplication[];\n  }\n\n  /**\n   * Find a XcodeSimulatorApplication on the XcodeSimulator for a given application directory path\n   * @param simulator The XcodeSimulator\n   * @param applicationDirectoryPath The application directory path\n   */\n  private static async findXcodeSimulatorApplication(\n    simulator: XcodeSimulator,\n    applicationDirectoryPath: string\n  ): Promise<XcodeSimulatorApplication | undefined> {\n    // Declare application file name\n    let applicationFileName: string;\n    try {\n      // Retrieve file names in application directory\n      const fileNames = await readDirectoryAsync(applicationDirectoryPath);\n      // Initialize matching application file name where file name ends with '.app'\n      const matchingApplicationFileName = fileNames.find((fileName) => fileName.endsWith(\".app\"));\n      // Check if matching application file name is unavailable\n      if (!matchingApplicationFileName) {\n        // Return no application\n        return undefined;\n      }\n      // Initialize Application file name\n      applicationFileName = matchingApplicationFileName;\n    } catch {\n      // On error return no application\n      return undefined;\n    }\n    // Declare Info.plist JSON\n    let infoPlistJSON: any;\n    try {\n      // Try to parse Info.plist JSON\n      // using 'plutil' to convert the Info.plist XML to JSON format\n      infoPlistJSON = JSON.parse(\n        (\n          await execAsync(\n            [\n              \"plutil\",\n              \"-convert\",\n              \"json\",\n              Path.join(\n                applicationDirectoryPath,\n                applicationFileName\n                  // Escape whitespaces\n                  .replace(\" \", \"\\\\ \"),\n                \"Info.plist\"\n              ),\n              \"-o\",\n              // By using a dash (\"-\") for the -o parameter value the output\n              // will be printed in the stdout instead into a local file\n              \"-\",\n            ].join(\" \")\n          )\n        ).stdout.trim()\n      );\n    } catch {\n      // Return no application\n      return undefined;\n    }\n    // Declare bundle identifier\n    const bundleIdentifier = infoPlistJSON[\"CFBundleIdentifier\"]?.trim();\n    // Check if bundle identifier is not available\n    if (!bundleIdentifier) {\n      // Return no application\n      return undefined;\n    }\n    // Find sandbox directory path\n    const sandBoxDirectoryPath = await XcodeSimulatorApplicationService.findSandboxDirectoryPath(\n      simulator,\n      bundleIdentifier\n    );\n    // Check if SandBox directory path is not available\n    if (!sandBoxDirectoryPath) {\n      // Return no application\n      return undefined;\n    }\n    // Find appGroup directory path\n    const appGroupPath = await XcodeSimulatorApplicationService.findAppGroupDirectoryPath(simulator, bundleIdentifier);\n    // Retrieve version from Info.plist\n    const version = infoPlistJSON[\"CFBundleShortVersionString\"];\n    // Retrieve build number from Info.plist\n    const buildNumber = infoPlistJSON[\"CFBundleVersion\"];\n    // Retrieve application name from Info.plist\n    // by either using the `CFBundleDisplayName` or `CFBundleName`\n    // otherwise use application file name as fallback\n    const applicationName =\n      infoPlistJSON[\"CFBundleDisplayName\"] ?? infoPlistJSON[\"CFBundleName\"] ?? applicationFileName.split(\".\")[0];\n    // Retrieve primary app icon name from Info.plist\n    const primaryAppIconName = infoPlistJSON[\"CFBundleIcons\"]?.[\"CFBundlePrimaryIcon\"]?.[\"CFBundleIconFiles\"]?.at(0);\n    // Declare an optional app icon path\n    let appIconPath: string | undefined;\n    // Check if a primary app icon name is available\n    if (primaryAppIconName) {\n      try {\n        // Read file names in application\n        const applicationFileNames = await readDirectoryAsync(Path.join(applicationDirectoryPath, applicationFileName));\n        // Find matching application file name that starts with the primary app icon name\n        const matchingApplicationFileName = applicationFileNames.find((fileName) =>\n          fileName.startsWith(primaryAppIconName)\n        );\n        // Check if a matching application file name is available\n        if (matchingApplicationFileName) {\n          // Initialize app icon path\n          appIconPath = Path.join(applicationDirectoryPath, applicationFileName, matchingApplicationFileName);\n        }\n      } catch {\n        // Simply ignore this error\n        // as we treat the appIconPath as an optional value\n      }\n    }\n    // Initialize user defaults plist path\n    let userDefaultsPlistPath: string | undefined = Path.join(\n      sandBoxDirectoryPath,\n      \"Library\",\n      \"Preferences\",\n      `${bundleIdentifier}.plist`\n    );\n    // Check if user defaults plist does not exists\n    if (!(await existsAsync(userDefaultsPlistPath))) {\n      // Clear user defaults plist path\n      userDefaultsPlistPath = undefined;\n    }\n    // Return Application\n    return {\n      id: [simulator.udid, bundleIdentifier].join(\"/\"),\n      name: applicationName,\n      bundleIdentifier: bundleIdentifier,\n      version: version,\n      buildNumber: buildNumber,\n      appIconPath: appIconPath,\n      simulator: simulator,\n      bundlePath: applicationDirectoryPath,\n      sandBoxPath: sandBoxDirectoryPath,\n      sandBoxDocumentsPath: Path.join(sandBoxDirectoryPath, \"Documents\"),\n      sandBoxCachesPath: Path.join(sandBoxDirectoryPath, \"Library\", \"Caches\"),\n      appGroupPath: appGroupPath,\n      userDefaultsPlistPath: userDefaultsPlistPath,\n    };\n  }\n\n  /**\n   * Find Sandbox directory path for a given XcodeSimulator and bundle identifier\n   * @param simulator The XcodeSimulator\n   * @param bundleIdentifier The bundle identifier\n   * @private\n   */\n  private static async findSandboxDirectoryPath(\n    simulator: XcodeSimulator,\n    bundleIdentifier: string\n  ): Promise<string | undefined> {\n    // Check if simulator is booted\n    if (simulator.state === XcodeSimulatorState.booted) {\n      try {\n        // Try to retrieve sandbox directory path via the simctl cli\n        // which is much quicker than the following fallback mechanism\n        return (\n          await execAsync(`xcrun simctl get_app_container ${simulator.udid} ${bundleIdentifier} data`)\n        ).stdout.trim();\n        // eslint-disable-next-line no-empty\n      } catch {\n        // Ignore error as we continue with the fallback mechanism\n      }\n    }\n    // Initialize simulator sandbox paths promise by using the cache\n    let simulatorSandBoxPathsPromise = XcodeSimulatorApplicationService.simulatorSandBoxPathsCache.get(simulator);\n    // Check if simulator sandbox paths promise is unavailable / no cache entry is available\n    if (!simulatorSandBoxPathsPromise) {\n      // Initialize simulator data application directory path\n      const dataApplicationDirectoryPath = Path.join(simulator.dataPath, \"Containers/Data/Application\");\n      //get sandbox paths from a directory\n      simulatorSandBoxPathsPromise = this.getApplicationPathFromDirectory(dataApplicationDirectoryPath);\n      // Set simulator sandbox paths promise so that the sandbox paths are only read once per simulator\n      XcodeSimulatorApplicationService.simulatorSandBoxPathsCache.set(simulator, simulatorSandBoxPathsPromise);\n    }\n    // Return sandbox path where the bundle identifier matches\n    return (await simulatorSandBoxPathsPromise)?.find(\n      (simulatorSandBoxPath) => simulatorSandBoxPath.bundleIdentifier === bundleIdentifier\n    )?.path;\n  }\n\n  /**\n   * Find AppGroup directory path for a given XcodeSimulator and bundle identifier\n   * @param simulator The XcodeSimulator\n   * @param bundleIdentifier The bundle identifier\n   * @private\n   */\n  private static async findAppGroupDirectoryPath(\n    simulator: XcodeSimulator,\n    bundleIdentifier: string\n  ): Promise<string | undefined> {\n    // Check if simulator is booted\n    if (simulator.state === XcodeSimulatorState.booted) {\n      try {\n        // Try to retrieve AppGroup directory path via the simctl cli\n        // which is much quicker than the following fallback mechanism\n        const xcrunResult = (\n          await execAsync(`xcrun simctl get_app_container ${simulator.udid} ${bundleIdentifier} groups`)\n        ).stdout.trim();\n        if (xcrunResult.length > 0) {\n          const groupPathSplit = xcrunResult.split(\"\\t\");\n          if (groupPathSplit.length === 2) {\n            return groupPathSplit[1].replaceAll(\"\\n\", \"\");\n          }\n        }\n        // eslint-disable-next-line no-empty\n      } catch {\n        // Ignore error as we continue with the fallback mechanism\n      }\n    }\n    // Initialize simulator AppGroup paths promise by using the cache\n    let simulatorAppGroupPathsPromise = XcodeSimulatorApplicationService.simulatorAppGroupPathsCache.get(simulator);\n    // Check if simulator AppGroup paths promise is unavailable / no cache entry is available\n    if (!simulatorAppGroupPathsPromise) {\n      // Initialize simulator data application directory path\n      const appGroupDirectoryPath = Path.join(simulator.dataPath, \"Containers/Shared/AppGroup\");\n      //get AppGroup paths from a directory\n      simulatorAppGroupPathsPromise =\n        XcodeSimulatorApplicationService.getApplicationPathFromDirectory(appGroupDirectoryPath);\n      // Set simulator AppGroup paths promise so that the AppGroup paths are only read once per simulator\n      XcodeSimulatorApplicationService.simulatorAppGroupPathsCache.set(simulator, simulatorAppGroupPathsPromise);\n    }\n    // Return AppGroup path where the bundle identifier matches\n    return (await simulatorAppGroupPathsPromise)?.find(\n      (simulatorAppGroupxPath) => simulatorAppGroupxPath.bundleIdentifier === `group.${bundleIdentifier}`\n    )?.path;\n  }\n\n  /**\n   * Get Application Path from a Directory\n   * @param applicationPath The Application path Inside a Container\n   * @private\n   */\n  private static async getApplicationPathFromDirectory(\n    applicationPath: string\n  ): Promise<XcodeSimulatorApplicationPath[]> {\n    // 1. Reading the data application directory path child directories\n    // 2. Retrieve all bundle identifiers alongside with the directory path (Sandbox | AppGroup)\n    return execAsync(\n      [\n        // List all child directories in data application directory\n        `ls -l ${applicationPath}`,\n        // Format output in the following format \"{Month}-{Day}-{Hour}-{Minute} {Path}\"\n        `awk '{print $6 \"-\" $7 \"-\" $8 \" \" $9}'`,\n        // Remove duplicates by first component (separated by whitespace)\n        `awk '!seen[$1]++'`,\n        // Drop first component (separated by whitespace)\n        `awk '{$1=\"\"; print $0}'`,\n      ].join(\" | \")\n    )\n      .then((output) =>\n        output.stdout\n          .trim()\n          .split(\"\\n\")\n          .map((path) => Path.join(applicationPath, path.trim()))\n      )\n      .then((paths) =>\n        Promise.allSettled(\n          paths.map((path) =>\n            execAsync(\n              [\n                \"defaults\",\n                \"read\",\n                Path.join(path, \".com.apple.mobile_container_manager.metadata.plist\"),\n                \"MCMMetadataIdentifier\",\n              ].join(\" \")\n            ).then((output) => {\n              const bundleIdentifier = output.stdout.trim();\n              if (bundleIdentifier) {\n                return {\n                  bundleIdentifier: bundleIdentifier,\n                  path: path,\n                };\n              } else {\n                return undefined;\n              }\n            })\n          )\n        ).then(\n          (results) =>\n            results\n              .map((result) => (result.status == \"fulfilled\" ? result.value : undefined))\n              .filter(Boolean) as XcodeSimulatorApplicationPath[]\n        )\n      );\n  }\n}\n"],
  "mappings": "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",
  "names": ["xcode_simulator_applications_exports", "__export", "xcode_simulator_applications_default", "__toCommonJS", "import_child_process", "import_util", "execAsync", "groupBy", "list", "keyProvider", "map", "value", "key", "values", "import_api", "XcodeService", "_XcodeService", "application", "execAsync", "XcodeSimulatorOpenUrlError", "reason", "XcodeSimulatorService", "_XcodeSimulatorService", "execAsync", "filter", "simulators", "groupBy", "value", "simulator", "group", "lhs", "rhs", "output", "devicesResponseJSON", "deviceGroup", "runtimeComponents", "runtime", "xcodeSimulatorUDID", "xcodeSimulator", "action", "bundleIdentifier", "serviceType", "url", "simulatorUDID", "trimmedUrl", "XcodeSimulatorOpenUrlError", "XcodeService", "payloadPath", "containerPath", "appGroupPath", "deleteAppGroupPathPromise", "name", "import_fs", "existsAsync", "path", "fs", "readDirectoryAsync", "makeDirectoryAsync", "removeDirectoryAsync", "readFileAsync", "writeFileAsync", "deleteFileAsync", "Path", "XcodeSimulatorApplicationService", "_XcodeSimulatorApplicationService", "xcodeSimulatorApplications", "groupBy", "application", "group", "lhs", "rhs", "simulators", "XcodeSimulatorService", "result", "simulator", "containerApplicationDirectoryPath", "applicationDirectoryPaths", "readDirectoryAsync", "entries", "entry", "applicationDirectoryPath", "applicationFileName", "matchingApplicationFileName", "fileName", "infoPlistJSON", "execAsync", "bundleIdentifier", "sandBoxDirectoryPath", "appGroupPath", "version", "buildNumber", "applicationName", "primaryAppIconName", "appIconPath", "userDefaultsPlistPath", "existsAsync", "simulatorSandBoxPathsPromise", "dataApplicationDirectoryPath", "simulatorSandBoxPath", "xcrunResult", "groupPathSplit", "simulatorAppGroupPathsPromise", "appGroupDirectoryPath", "simulatorAppGroupxPath", "applicationPath", "output", "path", "paths", "results", "xcode_simulator_applications_default", "XcodeSimulatorApplicationService"]
}
