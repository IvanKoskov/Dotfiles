{
  "version": 3,
  "sources": ["../../src/tools/xcode-swift-package-resolved.ts", "../../src/shared/fs-async.ts", "../../src/services/xcode-swift-package-resolved.service.ts", "../../src/shared/exec-async.ts"],
  "sourcesContent": ["import { XcodeSwiftPackageResolvedService } from \"../services/xcode-swift-package-resolved.service\";\n\ntype Input = {\n  /** The path to the directory containing the Xcode project. */\n  xcodeProjectDirectoryPath: string;\n};\n\n/**\n * Retrieves the Swift Package Resolved file for an Xcode project.\n * @param input The input.\n */\nexport default (input: Input) => XcodeSwiftPackageResolvedService.getPackageResolved(input.xcodeProjectDirectoryPath);\n", "import fs from \"fs\";\nimport { PathLike } from \"node:fs\";\n\n/**\n * Exists\n */\nexport const existsAsync = (path: PathLike) => {\n  return fs.promises\n    .access(path, fs.constants.F_OK)\n    .then(() => true)\n    .catch(() => false);\n};\n\n/**\n * Read directory\n */\nexport const readDirectoryAsync = fs.promises.readdir;\n\n/**\n * Make directory\n */\nexport const makeDirectoryAsync = fs.promises.mkdir;\n\n/**\n * Remove directory\n */\nexport const removeDirectoryAsync = fs.promises.rm;\n\n/**\n * Read file\n */\nexport const readFileAsync = fs.promises.readFile;\n\n/**\n * Write file\n */\nexport const writeFileAsync = fs.promises.writeFile;\n\n/**\n * Delete file\n */\nexport const deleteFileAsync = fs.promises.rm;\n", "import { existsAsync, readDirectoryAsync, readFileAsync } from \"../shared/fs-async\";\nimport Path from \"path\";\nimport { XcodeSwiftPackageResolved } from \"../models/swift-package-resolved/xcode-swift-package-resolved.model\";\nimport { XcodeSwiftPackageResolvedEntry } from \"../models/swift-package-resolved/xcode-swift-package-resolved-entry.model\";\nimport { execAsync } from \"../shared/exec-async\";\n\n/**\n * XcodeSwiftPackageResolvedService\n */\nexport class XcodeSwiftPackageResolvedService {\n  /**\n   * Retrieve Xcode Swift Package Resolved (Package.resolved) for a given Xcode Project\n   * @param xcodeProjectDirectoryPath The Xcode Project directory path\n   */\n  static async getPackageResolved(xcodeProjectDirectoryPath: string): Promise<XcodeSwiftPackageResolved> {\n    // Find the path to a package resolved file\n    const packageResolvedPath = await XcodeSwiftPackageResolvedService.findPackageResolvedPath(\n      xcodeProjectDirectoryPath\n    );\n    // Retrieve the contents of the package resolved and parse it as JSON\n    const packageResolved = JSON.parse(await readFileAsync(packageResolvedPath, \"utf-8\"));\n    // Initialize the package resolved pins\n    const packageResolvedPins = packageResolved.pins ?? packageResolved.object?.pins;\n    // Check if no package resolved pins are available\n    if (!packageResolvedPins) {\n      // Throw error\n      throw Error(\"Invalid Package.resolved contents\");\n    }\n    // Return Xcode Swift Package Resolved\n    return {\n      path: packageResolvedPath,\n      entries: (packageResolvedPins as any[]).map((packageResolvedPin: any) => {\n        return {\n          name: packageResolvedPin.identity ?? packageResolvedPin.package,\n          location: packageResolvedPin.location ?? packageResolvedPin.repositoryURL,\n          branch: packageResolvedPin.state?.branch,\n          revision: packageResolvedPin.state?.revision,\n          version: packageResolvedPin.state?.version,\n        };\n      }),\n    };\n  }\n\n  /**\n   * Retrieve the latest version / tag for a given Xcode Swift Package Resolved Entry\n   * @param entry The Xcode Swift Package Resolved Entry to retrieve the latest version\n   */\n  static getLatestVersion(entry: XcodeSwiftPackageResolvedEntry): Promise<string> {\n    return execAsync(\n      [`git ls-remote --tags --refs --sort=\"v:refname\" ${entry.location}`, \"tail -n1\", \"sed 's/.*\\\\///'\"].join(\" | \")\n    ).then((output) => output.stdout.trim());\n  }\n\n  /**\n   * Find the path to a \"Package.resolved\" at a given directory\n   * @param directoryPath The directory path\n   */\n  private static async findPackageResolvedPath(directoryPath: string): Promise<string> {\n    // Check if a \"Package.resolved\" file is available\n    if (await existsAsync(Path.join(directoryPath, \"Package.resolved\"))) {\n      // Return \"Package.resolved\" file path\n      return Path.join(directoryPath, \"Package.resolved\");\n    }\n    // Read the contents of the directory\n    const directoryContents = await readDirectoryAsync(directoryPath);\n    // Find a file which has a \".xcodeproj\" suffix\n    const project = directoryContents.find((file) => file.endsWith(\".xcodeproj\"));\n    // Check if a project file is available\n    if (project) {\n      // Initialize the project package resolved path\n      const packageResolvedPath = Path.join(\n        directoryPath,\n        project,\n        \"project.xcworkspace/xcshareddata/swiftpm/Package.resolved\"\n      );\n      // Check if the package resolved path exists\n      if (await existsAsync(packageResolvedPath)) {\n        // Return package resolved path of project\n        return packageResolvedPath;\n      }\n    }\n    // Find a file which has a \".xcworkspace\" suffix\n    const workspace = directoryContents.find((file) => file.endsWith(\".xcworkspace\"));\n    // Check if a workspace file is available\n    if (workspace) {\n      // Initialize the workspace package resolved path\n      const packageResolvedPath = Path.join(directoryPath, workspace, \"xcshareddata/swiftpm/Package.resolved\");\n      // Check if the package resolved path exists\n      if (await existsAsync(packageResolvedPath)) {\n        // Return package resolved path of workspace\n        return packageResolvedPath;\n      }\n    }\n    // Check if a \".package.resolved\" file is available\n    if (await existsAsync(Path.join(directoryPath, \".package.resolved\"))) {\n      // Return \".package.resolved\" file path\n      return Path.join(directoryPath, \".package.resolved\");\n    }\n    // Otherwise throw an error as no package resolved path could be found\n    throw Error(\"No Package.resolved has been found\");\n  }\n}\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n/**\n * Spawns a shell then executes the command within that shell, buffering any generated output.\n */\nexport const execAsync = promisify(exec);\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GCAA,IAAAI,EAAe,iBAMFC,EAAeC,GACnB,EAAAC,QAAG,SACP,OAAOD,EAAM,EAAAC,QAAG,UAAU,IAAI,EAC9B,KAAK,IAAM,EAAI,EACf,MAAM,IAAM,EAAK,EAMTC,EAAqB,EAAAD,QAAG,SAAS,QAKjCE,EAAqB,EAAAF,QAAG,SAAS,MAKjCG,EAAuB,EAAAH,QAAG,SAAS,GAKnCI,EAAgB,EAAAJ,QAAG,SAAS,SAK5BK,EAAiB,EAAAL,QAAG,SAAS,UAK7BM,EAAkB,EAAAN,QAAG,SAAS,GCxC3C,IAAAO,EAAiB,mBCDjB,IAAAC,EAAqB,yBACrBC,EAA0B,gBAKbC,KAAY,aAAU,MAAI,EDGhC,IAAMC,EAAN,MAAMC,CAAiC,CAK5C,aAAa,mBAAmBC,EAAuE,CAErG,IAAMC,EAAsB,MAAMF,EAAiC,wBACjEC,CACF,EAEME,EAAkB,KAAK,MAAM,MAAMC,EAAcF,EAAqB,OAAO,CAAC,EAE9EG,EAAsBF,EAAgB,MAAQA,EAAgB,QAAQ,KAE5E,GAAI,CAACE,EAEH,MAAM,MAAM,mCAAmC,EAGjD,MAAO,CACL,KAAMH,EACN,QAAUG,EAA8B,IAAKC,IACpC,CACL,KAAMA,EAAmB,UAAYA,EAAmB,QACxD,SAAUA,EAAmB,UAAYA,EAAmB,cAC5D,OAAQA,EAAmB,OAAO,OAClC,SAAUA,EAAmB,OAAO,SACpC,QAASA,EAAmB,OAAO,OACrC,EACD,CACH,CACF,CAMA,OAAO,iBAAiBC,EAAwD,CAC9E,OAAOC,EACL,CAAC,kDAAkDD,EAAM,QAAQ,GAAI,WAAY,iBAAiB,EAAE,KAAK,KAAK,CAChH,EAAE,KAAME,GAAWA,EAAO,OAAO,KAAK,CAAC,CACzC,CAMA,aAAqB,wBAAwBC,EAAwC,CAEnF,GAAI,MAAMC,EAAY,EAAAC,QAAK,KAAKF,EAAe,kBAAkB,CAAC,EAEhE,OAAO,EAAAE,QAAK,KAAKF,EAAe,kBAAkB,EAGpD,IAAMG,EAAoB,MAAMC,EAAmBJ,CAAa,EAE1DK,EAAUF,EAAkB,KAAMG,GAASA,EAAK,SAAS,YAAY,CAAC,EAE5E,GAAID,EAAS,CAEX,IAAMb,EAAsB,EAAAU,QAAK,KAC/BF,EACAK,EACA,2DACF,EAEA,GAAI,MAAMJ,EAAYT,CAAmB,EAEvC,OAAOA,CAEX,CAEA,IAAMe,EAAYJ,EAAkB,KAAMG,GAASA,EAAK,SAAS,cAAc,CAAC,EAEhF,GAAIC,EAAW,CAEb,IAAMf,EAAsB,EAAAU,QAAK,KAAKF,EAAeO,EAAW,uCAAuC,EAEvG,GAAI,MAAMN,EAAYT,CAAmB,EAEvC,OAAOA,CAEX,CAEA,GAAI,MAAMS,EAAY,EAAAC,QAAK,KAAKF,EAAe,mBAAmB,CAAC,EAEjE,OAAO,EAAAE,QAAK,KAAKF,EAAe,mBAAmB,EAGrD,MAAM,MAAM,oCAAoC,CAClD,CACF,EF1FA,IAAOQ,EAASC,GAAiBC,EAAiC,mBAAmBD,EAAM,yBAAyB",
  "names": ["xcode_swift_package_resolved_exports", "__export", "xcode_swift_package_resolved_default", "__toCommonJS", "import_fs", "existsAsync", "path", "fs", "readDirectoryAsync", "makeDirectoryAsync", "removeDirectoryAsync", "readFileAsync", "writeFileAsync", "deleteFileAsync", "import_path", "import_child_process", "import_util", "execAsync", "XcodeSwiftPackageResolvedService", "_XcodeSwiftPackageResolvedService", "xcodeProjectDirectoryPath", "packageResolvedPath", "packageResolved", "readFileAsync", "packageResolvedPins", "packageResolvedPin", "entry", "execAsync", "output", "directoryPath", "existsAsync", "Path", "directoryContents", "readDirectoryAsync", "project", "file", "workspace", "xcode_swift_package_resolved_default", "input", "XcodeSwiftPackageResolvedService"]
}
